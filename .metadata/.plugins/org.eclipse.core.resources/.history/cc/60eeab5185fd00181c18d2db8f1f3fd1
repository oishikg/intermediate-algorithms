package sorting;


public class PriorityQueue 
{
	/* instance variables: note that we only implement a pq for integers, 
	 * and a variable N to keep track of the size of the pq */
	int[] pq; 
	int N = 0;
	int defaultPqSize = 5;
	
	/* constructor to instantiate the priority queue with a default  
	 * initial size; in addition to the initial size, we implement 
	 * the pq with array resizing */
	public PriorityQueue ()
	{
		pq = new int [defaultPqSize];
	}
	
	/* instance methods */
	
	/* private helper method to resize the pq */
	private void resize(int max)
	{
		int [] temp = new int[max];
		for (int i=0; i<N ; i++)
			temp[i] = pq [i];
		pq = temp;
	}
	
	/* helper function to exchange items based on keys */
	private void exchange (int k1, int k2)
	{
		int temp = pq [k1];
		pq [k1] = pq [k2];
		pq [k2] = temp;
	}
	
	/* swim() implementation */
	private void swim ()
	{
		/* set k to N, where the most recently inserted element sits */
		int k = N;
		
		/* swim up based on the heap criterion */
		while ( k > 0)
		{
			if (pq [k/2] < pq [k])
				exchange (k/2, k);
			k /= 2;
		}
	}
	
	/* sink () implementation */
	private void sink ()
	{
		int k = 1;
		while (2*k < N)
		{
			/* first find the larger of the two children */
			int largerChildIndex = 0;
			if (pq [2*k] > pq [2*k + 1])
				largerChildIndex = 2*k;
			else
				largerChildIndex = 2*k + 1;
			
			/* now check if the parent is lesser; if so,
			 * swap and continue sinking, otherwise break
			 */
			if (pq[k] < pq[largerChildIndex])
			{
				exchange (k, largerChildIndex);
				k = largerChildIndex;
				continue;
			}
			else
				break;
		}
		
	}
	
	/* method to return current size of pq */
	public int size ()
	{
		return N;
	}
		
	/* insert operation: recall that to insert a value in the pq, we place it at the
	 * end of the pq, and then swim up to reheapify */
	public void insert (int key)
	{
		/* check if resizing is required */
		if (N == pq.length)
			resize (2 * pq.length);
				
		/* next, increment the pq size by 1, and then insert key at the end;
		 * note that we increment N first to follow the convention of leaving
		 * pq[0] empty*/ 
		pq [++N] = key;
		
		/* finally, reheapify by invoking swim */
		swim ();
	}
	
	/* deleteMax operation : delete the item in pq[1], reduce size of heap by 1, bring 
	 * item from end of of heap to the root position, them reheapify, this time by sinking*/
	public int deleteMax ()
	{
		/* extract the max item */
		int max = pq[1];
		
		/* place item at end of heap in its position and decrement heap size */
		pq[1] = pq [N--];
		
		/* check if resizing is required */
		if (N > 0 && N < pq.length/4)
			resize (pq.length/2);
		
		/* reheapify by sinking */
		sink ();
		
		/* return the maximum value */
		return max;
	}
	
	/* function to print pq in its current form */
	public void printPq ()
	{
		System.out.println ("The pq is currently as follows: ")
		for (int i = 1 ; i <= N ; i++)
			System.out.println(pq[i]);
	}
	
	
	
	
	
	
}
